using System;
using System.Collections.Generic;
using System.Linq;
using VaultScope.Core.Models;

namespace VaultScope.Core.Services;

public class VulnerabilityAnalyzer
{
    public VulnerabilityAnalysis Analyze(List<Vulnerability> vulnerabilities)
    {
        var analysis = new VulnerabilityAnalysis();
        
        if (!vulnerabilities.Any())
        {
            analysis.Summary = "No vulnerabilities detected.";
            return analysis;
        }
        
        // Group by severity
        var bySeverity = vulnerabilities.GroupBy(v => v.Severity)
            .OrderByDescending(g => g.Key)
            .ToDictionary(g => g.Key, g => g.ToList());
        
        analysis.BySeverity = bySeverity;
        
        // Group by type
        var byType = vulnerabilities.GroupBy(v => v.Type)
            .OrderByDescending(g => g.Count())
            .ToDictionary(g => g.Key, g => g.ToList());
        
        analysis.ByType = byType;
        
        // Most affected endpoints
        var affectedEndpoints = vulnerabilities
            .GroupBy(v => v.AffectedEndpoint)
            .OrderByDescending(g => g.Count())
            .Take(10)
            .Select(g => new EndpointRisk
            {
                Endpoint = g.Key,
                VulnerabilityCount = g.Count(),
                HighestSeverity = g.Max(v => v.Severity),
                VulnerabilityTypes = g.Select(v => v.Type).Distinct().ToList()
            })
            .ToList();
        
        analysis.MostAffectedEndpoints = affectedEndpoints;
        
        // Risk assessment
        analysis.OverallRisk = CalculateOverallRisk(vulnerabilities);
        
        // Trends and patterns
        analysis.CommonPatterns = IdentifyPatterns(vulnerabilities);
        
        // Recommendations
        analysis.TopRecommendations = GenerateRecommendations(vulnerabilities);
        
        // Summary
        analysis.Summary = GenerateSummary(vulnerabilities, analysis);
        
        return analysis;
    }
    
    private RiskLevel CalculateOverallRisk(List<Vulnerability> vulnerabilities)
    {
        var criticalCount = vulnerabilities.Count(v => v.Severity == VulnerabilitySeverity.Critical);
        var highCount = vulnerabilities.Count(v => v.Severity == VulnerabilitySeverity.High);
        var mediumCount = vulnerabilities.Count(v => v.Severity == VulnerabilitySeverity.Medium);
        
        if (criticalCount > 0)
            return RiskLevel.Critical;
        
        if (highCount >= 3)
            return RiskLevel.High;
        
        if (highCount > 0 || mediumCount >= 5)
            return RiskLevel.Medium;
        
        if (mediumCount > 0)
            return RiskLevel.Low;
        
        return RiskLevel.Minimal;
    }
    
    private List<string> IdentifyPatterns(List<Vulnerability> vulnerabilities)
    {
        var patterns = new List<string>();
        
        // Check for systemic issues
        var injectionVulns = vulnerabilities.Where(v => 
            v.Type.Contains("Injection", StringComparison.OrdinalIgnoreCase)).ToList();
        
        if (injectionVulns.Count > 3)
        {
            patterns.Add("Systemic input validation issues detected across multiple endpoints");
        }
        
        // Check for authentication issues
        var authVulns = vulnerabilities.Where(v => 
            v.Type.Contains("Auth", StringComparison.OrdinalIgnoreCase)).ToList();
        
        if (authVulns.Any())
        {
            patterns.Add("Authentication and authorization weaknesses present");
        }
        
        // Check for configuration issues
        var configVulns = vulnerabilities.Where(v => 
            v.Type.Contains("Configuration", StringComparison.OrdinalIgnoreCase) ||
            v.Type.Contains("Headers", StringComparison.OrdinalIgnoreCase)).ToList();
        
        if (configVulns.Count > 2)
        {
            patterns.Add("Multiple security misconfigurations detected");
        }
        
        // Check for outdated practices
        if (vulnerabilities.Any(v => v.Evidence?.Contains("deprecated", StringComparison.OrdinalIgnoreCase) == true))
        {
            patterns.Add("Use of deprecated security practices");
        }
        
        return patterns;
    }
    
    private List<Recommendation> GenerateRecommendations(List<Vulnerability> vulnerabilities)
    {
        var recommendations = new List<Recommendation>();
        
        // Critical vulnerabilities first
        var criticalVulns = vulnerabilities.Where(v => v.Severity == VulnerabilitySeverity.Critical).ToList();
        if (criticalVulns.Any())
        {
            recommendations.Add(new Recommendation
            {
                Priority = RecommendationPriority.Immediate,
                Title = "Address Critical Vulnerabilities",
                Description = $"Fix {criticalVulns.Count} critical vulnerabilities immediately",
                AffectedVulnerabilities = criticalVulns.Select(v => v.Id).ToList()
            });
        }
        
        // Input validation
        if (vulnerabilities.Any(v => v.Type.Contains("Injection", StringComparison.OrdinalIgnoreCase)))
        {
            recommendations.Add(new Recommendation
            {
                Priority = RecommendationPriority.High,
                Title = "Implement Input Validation Framework",
                Description = "Deploy comprehensive input validation and sanitization across all endpoints",
                Category = "Development Practice"
            });
        }
        
        // Authentication
        if (vulnerabilities.Any(v => v.Type.Contains("Auth", StringComparison.OrdinalIgnoreCase)))
        {
            recommendations.Add(new Recommendation
            {
                Priority = RecommendationPriority.High,
                Title = "Strengthen Authentication Mechanisms",
                Description = "Implement multi-factor authentication and review access control policies",
                Category = "Access Control"
            });
        }
        
        // Security headers
        if (vulnerabilities.Any(v => v.Type.Contains("Headers", StringComparison.OrdinalIgnoreCase)))
        {
            recommendations.Add(new Recommendation
            {
                Priority = RecommendationPriority.Medium,
                Title = "Configure Security Headers",
                Description = "Implement comprehensive security headers across all responses",
                Category = "Configuration"
            });
        }
        
        // Rate limiting
        if (vulnerabilities.Any(v => v.Type.Contains("Rate", StringComparison.OrdinalIgnoreCase)))
        {
            recommendations.Add(new Recommendation
            {
                Priority = RecommendationPriority.Medium,
                Title = "Implement Rate Limiting",
                Description = "Deploy rate limiting to prevent abuse and brute force attacks",
                Category = "Infrastructure"
            });
        }
        
        // General recommendations
        recommendations.Add(new Recommendation
        {
            Priority = RecommendationPriority.Medium,
            Title = "Regular Security Assessments",
            Description = "Schedule quarterly security assessments and penetration testing",
            Category = "Process"
        });
        
        recommendations.Add(new Recommendation
        {
            Priority = RecommendationPriority.Low,
            Title = "Security Training",
            Description = "Provide secure coding training to development team",
            Category = "Training"
        });
        
        return recommendations.OrderBy(r => r.Priority).Take(10).ToList();
    }
    
    private string GenerateSummary(List<Vulnerability> vulnerabilities, VulnerabilityAnalysis analysis)
    {
        var summary = $"Security assessment completed. Found {vulnerabilities.Count} vulnerabilities ";
        summary += $"({vulnerabilities.Count(v => v.Severity == VulnerabilitySeverity.Critical)} critical, ";
        summary += $"{vulnerabilities.Count(v => v.Severity == VulnerabilitySeverity.High)} high, ";
        summary += $"{vulnerabilities.Count(v => v.Severity == VulnerabilitySeverity.Medium)} medium, ";
        summary += $"{vulnerabilities.Count(v => v.Severity == VulnerabilitySeverity.Low)} low). ";
        summary += $"Overall risk level: {analysis.OverallRisk}. ";
        
        if (analysis.CommonPatterns.Any())
        {
            summary += $"Key findings: {string.Join("; ", analysis.CommonPatterns.Take(2))}. ";
        }
        
        summary += $"Immediate action required for {analysis.TopRecommendations.Count(r => r.Priority == RecommendationPriority.Immediate)} items.";
        
        return summary;
    }
}

public class VulnerabilityAnalysis
{
    public string Summary { get; set; } = string.Empty;
    public RiskLevel OverallRisk { get; set; }
    public Dictionary<VulnerabilitySeverity, List<Vulnerability>> BySeverity { get; set; } = new();
    public Dictionary<string, List<Vulnerability>> ByType { get; set; } = new();
    public List<EndpointRisk> MostAffectedEndpoints { get; set; } = new();
    public List<string> CommonPatterns { get; set; } = new();
    public List<Recommendation> TopRecommendations { get; set; } = new();
}

public class EndpointRisk
{
    public string Endpoint { get; set; } = string.Empty;
    public int VulnerabilityCount { get; set; }
    public VulnerabilitySeverity HighestSeverity { get; set; }
    public List<string> VulnerabilityTypes { get; set; } = new();
}

public class Recommendation
{
    public RecommendationPriority Priority { get; set; }
    public string Title { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public string Category { get; set; } = string.Empty;
    public List<Guid> AffectedVulnerabilities { get; set; } = new();
}

public enum RiskLevel
{
    Minimal,
    Low,
    Medium,
    High,
    Critical
}

public enum RecommendationPriority
{
    Immediate = 0,
    High = 1,
    Medium = 2,
    Low = 3
}