using VaultScope.Core.Models;
using VaultScope.Core.Services;
using Xunit;
using FluentAssertions;

namespace VaultScope.Tests.Unit;

public class VulnerabilityAnalyzerTests
{
    private readonly VulnerabilityAnalyzer _analyzer;

    public VulnerabilityAnalyzerTests()
    {
        _analyzer = new VulnerabilityAnalyzer();
    }

    [Fact]
    public void Analyze_EmptyVulnerabilityList_ShouldReturnMinimalRiskAnalysis()
    {
        // Arrange
        var vulnerabilities = new List<Vulnerability>();

        // Act
        var analysis = _analyzer.Analyze(vulnerabilities);

        // Assert
        analysis.Should().NotBeNull();
        analysis.Summary.Should().Be("No vulnerabilities detected.");
        analysis.OverallRisk.Should().Be(RiskLevel.Minimal);
        analysis.BySeverity.Should().BeEmpty();
        analysis.ByType.Should().BeEmpty();
        analysis.MostAffectedEndpoints.Should().BeEmpty();
        analysis.CommonPatterns.Should().BeEmpty();
        analysis.TopRecommendations.Should().NotBeEmpty(); // Should still have general recommendations
    }

    [Fact]
    public void Analyze_SingleCriticalVulnerability_ShouldReturnCriticalRisk()
    {
        // Arrange
        var vulnerabilities = new List<Vulnerability>
        {
            new Vulnerability
            {
                Type = "SQL Injection",
                Severity = VulnerabilitySeverity.Critical,
                Title = "Critical SQL Injection",
                AffectedEndpoint = "http://localhost:3000/api/users",
                HttpMethod = "POST"
            }
        };

        // Act
        var analysis = _analyzer.Analyze(vulnerabilities);

        // Assert
        analysis.Should().NotBeNull();
        analysis.OverallRisk.Should().Be(RiskLevel.Critical);
        analysis.BySeverity.Should().ContainKey(VulnerabilitySeverity.Critical);
        analysis.BySeverity[VulnerabilitySeverity.Critical].Should().HaveCount(1);
        analysis.ByType.Should().ContainKey("SQL Injection");
        analysis.ByType["SQL Injection"].Should().HaveCount(1);
        analysis.MostAffectedEndpoints.Should().HaveCount(1);
        analysis.MostAffectedEndpoints[0].Endpoint.Should().Be("http://localhost:3000/api/users");
        analysis.MostAffectedEndpoints[0].VulnerabilityCount.Should().Be(1);
        analysis.MostAffectedEndpoints[0].HighestSeverity.Should().Be(VulnerabilitySeverity.Critical);
        analysis.TopRecommendations.Should().Contain(r => r.Priority == RecommendationPriority.Immediate);
    }

    [Fact]
    public void Analyze_MultipleHighSeverityVulnerabilities_ShouldReturnHighRisk()
    {
        // Arrange
        var vulnerabilities = new List<Vulnerability>
        {
            new Vulnerability
            {
                Type = "XSS",
                Severity = VulnerabilitySeverity.High,
                Title = "XSS Vulnerability 1",
                AffectedEndpoint = "http://localhost:3000/api/search"
            },
            new Vulnerability
            {
                Type = "Authentication Bypass",
                Severity = VulnerabilitySeverity.High,
                Title = "Auth Bypass",
                AffectedEndpoint = "http://localhost:3000/api/admin"
            },
            new Vulnerability
            {
                Type = "XSS",
                Severity = VulnerabilitySeverity.High,
                Title = "XSS Vulnerability 2",
                AffectedEndpoint = "http://localhost:3000/api/profile"
            }
        };

        // Act
        var analysis = _analyzer.Analyze(vulnerabilities);

        // Assert
        analysis.Should().NotBeNull();
        analysis.OverallRisk.Should().Be(RiskLevel.High);
        analysis.BySeverity.Should().ContainKey(VulnerabilitySeverity.High);
        analysis.BySeverity[VulnerabilitySeverity.High].Should().HaveCount(3);
        analysis.ByType.Should().ContainKey("XSS");
        analysis.ByType["XSS"].Should().HaveCount(2);
        analysis.ByType.Should().ContainKey("Authentication Bypass");
        analysis.ByType["Authentication Bypass"].Should().HaveCount(1);
    }

    [Fact]
    public void Analyze_MixedSeverityVulnerabilities_ShouldCalculateCorrectRisk()
    {
        // Arrange
        var vulnerabilities = new List<Vulnerability>
        {
            new Vulnerability
            {
                Type = "SQL Injection",
                Severity = VulnerabilitySeverity.High,
                AffectedEndpoint = "http://localhost:3000/api/users"
            },
            new Vulnerability
            {
                Type = "Missing Security Headers",
                Severity = VulnerabilitySeverity.Medium,
                AffectedEndpoint = "http://localhost:3000/"
            },
            new Vulnerability
            {
                Type = "Information Disclosure",
                Severity = VulnerabilitySeverity.Low,
                AffectedEndpoint = "http://localhost:3000/api/version"
            },
            new Vulnerability
            {
                Type = "Missing Security Headers",
                Severity = VulnerabilitySeverity.Medium,
                AffectedEndpoint = "http://localhost:3000/api/data"
            }
        };

        // Act
        var analysis = _analyzer.Analyze(vulnerabilities);

        // Assert
        analysis.Should().NotBeNull();
        analysis.OverallRisk.Should().Be(RiskLevel.Medium); // 1 high + multiple medium = medium risk
        analysis.BySeverity.Should().HaveCount(3);
        analysis.BySeverity[VulnerabilitySeverity.High].Should().HaveCount(1);
        analysis.BySeverity[VulnerabilitySeverity.Medium].Should().HaveCount(2);
        analysis.BySeverity[VulnerabilitySeverity.Low].Should().HaveCount(1);
    }

    [Fact]
    public void Analyze_MultipleVulnerabilitiesOnSameEndpoint_ShouldGroupCorrectly()
    {
        // Arrange
        var endpoint = "http://localhost:3000/api/vulnerable";
        var vulnerabilities = new List<Vulnerability>
        {
            new Vulnerability
            {
                Type = "SQL Injection",
                Severity = VulnerabilitySeverity.Critical,
                AffectedEndpoint = endpoint
            },
            new Vulnerability
            {
                Type = "XSS",
                Severity = VulnerabilitySeverity.High,
                AffectedEndpoint = endpoint
            },
            new Vulnerability
            {
                Type = "Command Injection",
                Severity = VulnerabilitySeverity.High,
                AffectedEndpoint = endpoint
            }
        };

        // Act
        var analysis = _analyzer.Analyze(vulnerabilities);

        // Assert
        analysis.Should().NotBeNull();
        analysis.MostAffectedEndpoints.Should().HaveCount(1);
        var endpointRisk = analysis.MostAffectedEndpoints[0];
        endpointRisk.Endpoint.Should().Be(endpoint);
        endpointRisk.VulnerabilityCount.Should().Be(3);
        endpointRisk.HighestSeverity.Should().Be(VulnerabilitySeverity.Critical);
        endpointRisk.VulnerabilityTypes.Should().HaveCount(3);
        endpointRisk.VulnerabilityTypes.Should().Contain("SQL Injection");
        endpointRisk.VulnerabilityTypes.Should().Contain("XSS");
        endpointRisk.VulnerabilityTypes.Should().Contain("Command Injection");
    }

    [Fact]
    public void Analyze_InjectionVulnerabilities_ShouldIdentifySystemicPattern()
    {
        // Arrange
        var vulnerabilities = new List<Vulnerability>
        {
            new Vulnerability { Type = "SQL Injection", Severity = VulnerabilitySeverity.High },
            new Vulnerability { Type = "Command Injection", Severity = VulnerabilitySeverity.High },
            new Vulnerability { Type = "LDAP Injection", Severity = VulnerabilitySeverity.Medium },
            new Vulnerability { Type = "NoSQL Injection", Severity = VulnerabilitySeverity.Medium }
        };

        // Act
        var analysis = _analyzer.Analyze(vulnerabilities);

        // Assert
        analysis.Should().NotBeNull();
        analysis.CommonPatterns.Should().Contain("Systemic input validation issues detected across multiple endpoints");
    }

    [Fact]
    public void Analyze_AuthenticationVulnerabilities_ShouldIdentifyAuthPattern()
    {
        // Arrange
        var vulnerabilities = new List<Vulnerability>
        {
            new Vulnerability { Type = "Authentication Bypass", Severity = VulnerabilitySeverity.High },
            new Vulnerability { Type = "Authorization Issue", Severity = VulnerabilitySeverity.Medium }
        };

        // Act
        var analysis = _analyzer.Analyze(vulnerabilities);

        // Assert
        analysis.Should().NotBeNull();
        analysis.CommonPatterns.Should().Contain("Authentication and authorization weaknesses present");
    }

    [Fact]
    public void Analyze_ConfigurationVulnerabilities_ShouldIdentifyConfigPattern()
    {
        // Arrange
        var vulnerabilities = new List<Vulnerability>
        {
            new Vulnerability { Type = "Missing Security Headers", Severity = VulnerabilitySeverity.Medium },
            new Vulnerability { Type = "Server Configuration Issue", Severity = VulnerabilitySeverity.Low },
            new Vulnerability { Type = "HTTPS Configuration Problem", Severity = VulnerabilitySeverity.Medium }
        };

        // Act
        var analysis = _analyzer.Analyze(vulnerabilities);

        // Assert
        analysis.Should().NotBeNull();
        analysis.CommonPatterns.Should().Contain("Multiple security misconfigurations detected");
    }

    [Fact]
    public void Analyze_WithDeprecatedPractices_ShouldIdentifyPattern()
    {
        // Arrange
        var vulnerabilities = new List<Vulnerability>
        {
            new Vulnerability 
            { 
                Type = "Weak Cryptography", 
                Severity = VulnerabilitySeverity.Medium,
                Evidence = "Use of deprecated MD5 hashing algorithm"
            }
        };

        // Act
        var analysis = _analyzer.Analyze(vulnerabilities);

        // Assert
        analysis.Should().NotBeNull();
        analysis.CommonPatterns.Should().Contain("Use of deprecated security practices");
    }

    [Fact]
    public void Analyze_ShouldGenerateRecommendationsBySeverity()
    {
        // Arrange
        var vulnerabilities = new List<Vulnerability>
        {
            new Vulnerability { Type = "SQL Injection", Severity = VulnerabilitySeverity.Critical },
            new Vulnerability { Type = "XSS", Severity = VulnerabilitySeverity.High },
            new Vulnerability { Type = "Authentication Bypass", Severity = VulnerabilitySeverity.High },
            new Vulnerability { Type = "Missing Security Headers", Severity = VulnerabilitySeverity.Medium }
        };

        // Act
        var analysis = _analyzer.Analyze(vulnerabilities);

        // Assert
        analysis.Should().NotBeNull();
        analysis.TopRecommendations.Should().NotBeEmpty();
        
        // Should have immediate priority recommendation for critical vulnerabilities
        analysis.TopRecommendations.Should().Contain(r => r.Priority == RecommendationPriority.Immediate);
        
        // Should have high priority recommendation for injection vulnerabilities
        analysis.TopRecommendations.Should().Contain(r => 
            r.Priority == RecommendationPriority.High && 
            r.Title.Contains("Input Validation"));
        
        // Should have high priority recommendation for auth vulnerabilities
        analysis.TopRecommendations.Should().Contain(r => 
            r.Priority == RecommendationPriority.High && 
            r.Title.Contains("Authentication"));
        
        // Should have medium priority recommendation for security headers
        analysis.TopRecommendations.Should().Contain(r => 
            r.Priority == RecommendationPriority.Medium && 
            r.Title.Contains("Security Headers"));
    }

    [Fact]
    public void Analyze_ShouldGenerateCorrectSummary()
    {
        // Arrange
        var vulnerabilities = new List<Vulnerability>
        {
            new Vulnerability { Type = "SQL Injection", Severity = VulnerabilitySeverity.Critical },
            new Vulnerability { Type = "XSS", Severity = VulnerabilitySeverity.High },
            new Vulnerability { Type = "Missing Headers", Severity = VulnerabilitySeverity.Medium },
            new Vulnerability { Type = "Info Disclosure", Severity = VulnerabilitySeverity.Low }
        };

        // Act
        var analysis = _analyzer.Analyze(vulnerabilities);

        // Assert
        analysis.Should().NotBeNull();
        analysis.Summary.Should().NotBeNullOrEmpty();
        analysis.Summary.Should().Contain("4 vulnerabilities");
        analysis.Summary.Should().Contain("1 critical");
        analysis.Summary.Should().Contain("1 high");
        analysis.Summary.Should().Contain("1 medium");
        analysis.Summary.Should().Contain("1 low");
        analysis.Summary.Should().Contain("Overall risk level: Critical");
    }

    [Theory]
    [InlineData(0, 0, 0, 0, RiskLevel.Minimal)]
    [InlineData(1, 0, 0, 0, RiskLevel.Critical)]
    [InlineData(0, 3, 0, 0, RiskLevel.High)]
    [InlineData(0, 1, 5, 0, RiskLevel.Medium)]
    [InlineData(0, 0, 3, 0, RiskLevel.Low)]
    [InlineData(0, 0, 1, 5, RiskLevel.Low)]
    public void Analyze_ShouldCalculateCorrectRiskLevel(int critical, int high, int medium, int low, RiskLevel expectedRisk)
    {
        // Arrange
        var vulnerabilities = new List<Vulnerability>();
        
        for (int i = 0; i < critical; i++)
            vulnerabilities.Add(new Vulnerability { Severity = VulnerabilitySeverity.Critical, Type = $"Critical{i}" });
        
        for (int i = 0; i < high; i++)
            vulnerabilities.Add(new Vulnerability { Severity = VulnerabilitySeverity.High, Type = $"High{i}" });
        
        for (int i = 0; i < medium; i++)
            vulnerabilities.Add(new Vulnerability { Severity = VulnerabilitySeverity.Medium, Type = $"Medium{i}" });
        
        for (int i = 0; i < low; i++)
            vulnerabilities.Add(new Vulnerability { Severity = VulnerabilitySeverity.Low, Type = $"Low{i}" });

        // Act
        var analysis = _analyzer.Analyze(vulnerabilities);

        // Assert
        analysis.OverallRisk.Should().Be(expectedRisk);
    }
}